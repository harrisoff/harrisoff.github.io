---
layout: post
title: "WebGL 笔记"
date: 2020-03-27 22:01:00
categories: 笔记 javascript
---

[MDN - 常量](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGL_API/Constants)   
[WebGL Fundamentals 中文](https://webglfundamentals.org/webgl/lessons/zh_cn/)   
[WebGL fundamentals 中文 - 设置和安装](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-setup-and-installation.html)

## 概述

JS 不能操作 GPU，需要 GLSL 作为过渡。JS 通过 webgl API 为 GLSL 中的属性赋值，再由 GLSL 函数操作 GPU 进行绘制。

webgl 坐标系原点在左下，canvas 坐标系原点在左上。可以通过 GLSL 的矩阵运算翻转 y 轴来统一原点位置。

支持点、线、面三种图形的绘制，面只有三角形。

webgl 的整个流程，高度概括一下就是：
1. 创建着色器
2. 向着色器提供数据
3. 调用 `gl.drawArrays()` 或 `gl.drawElements()` 绘制

### canvas 基础

一个 `<canvas />` 元素有两种尺寸：
- canvas 内部的像素数
- 显示在屏幕上的像素数

下面是一个在屏幕上显示为 800x600 的画布，但是其内部实际的像素数量为 400x300。

```html
<canvas width="400" height="300" style="width:800px; height:600px"></canvas>
```

上面是宽高刚好为整数倍的情况，如果不是整数倍，就会出现比例失调。可以通过 `canvas.height = canvas.clientHeight` 使得内外像素数一致。

## space 空间

- clipspace 裁剪空间，范围 [-1, 1]
- colorspace 颜色空间，范围 [0, 1]

GLSL 使用的是 clipspace 的坐标数据，即值全部在 [-1 ,1] 范围内的数据。JS 可以直接提供这个区间内的数据，也可以提供 canvas 的坐标数据，然后在 GLSL 中添加一步处理操作，生成 clipspace 数据。

## WebGL API

### buffer 数组中数据的顺序

以 vertex shader 为例，buffer 中的数据是各个点的坐标，而各种图形都是通过三角形拼接而成，因此 buffer 也就是三角形的坐标。

每个三角形都有三个顶点，点的绘制顺序不同会使得三角形内部填充图案的方向不同。**注意，是内部图案方向不同，不是三角形轮廓方向不同**。纯色时是看不出来的，添加图片作为纹理就可以看出来了，图片的方向会发生变化，即上下左右四个方向。

> 当背景色是根据当前点的坐标计算的渐变色时，也看不出方向，因为点没有方向。

对于多个三角形，比如 2 个三角形拼接成的矩形，在填充图案非纯色时，需要保证内部填充图案方向一致，否则图像会被割裂。要实现方向一致，需要在提供数据时，使相邻的两个三角形的顶点坐标相同。

> 至于图案的整体方向，那是另一个问题了。

至于四个方向和顶点顺序之间的规律，涉及到添加纹理的步骤。见后面的纹理部分。

### 流程

```js
// ===== shader 源码 =====
const vertexShaderSrc = ''; // vertext shader 源码
const fragmentShaderSrc = ''; // fragment shader 源码
// ===== canvas 初始化 =====
const canvas = document.getElementById('canvas');
const gl = canvas.getContext('webgl');
// ===== shader 初始化 =====
// vertex shader
const vertexShader = gl.createShader(gl.VERTEX_SHADER); // 创建 shader
gl.shaderSource(vertexShader, vertexShaderSrc);// 绑定源码
gl.compileShader(vertexShader);// 编译
// fragment shader 略
// ...
// ===== program 初始化 =====
const shaderProgram = gl.createProgram(); // 创建 program
gl.attachShader(shaderProgram, vertexShader); // 添加 vertext shader
gl.attachShader(shaderProgram, fragmentShader); // 添加 fragment shader
gl.linkProgram(shaderProgram); // 链接
gl.useProgram(shaderProgram); // 使用
// ===== attribute 赋值 =====
// 详情后面 attribute 部分
// ===== 绘制 =====
const primitiveType = gl.TRIANGLES; // 图像的形状
const drawOffset = 0; // 偏移
const count = bufferData.length / size; // 执行次数，见后面的 attribute 部分
gl.drawArrays(primitiveType, drawOffset, count);
```

## OpenGL Shading Language

OpenGL Shading Language，aka GLSLang/GLSL，着色器使用的语言，基于 C。

> 好像也有说是 Graphic Library Shader Language 的

GLSL 需要提供成对的方法，或称为着色器，每一对方法叫一个着色器程序 program，包括一个顶点着色器 vertex shader，一个片段着色器 fragment shader。

每行结尾必须有分号。

有很多内置方法，比如三角函数。

### 数据类型

- vec[234]，一维矢量
- mat[234]，二维矩阵
- sampler2D，纹理，范围 [0, 1]
- bool，布尔值
- bvec[234]

数据可以是 32 位浮点数据或 8 位无符号整型数据，对应 JS 的 `Float32Array` 和 `Uint8Array`。

#### 1. vec

`vec4` 表示长度为 4 的数据，有 4 种索引：
- `{ x, y, z, w }`
- `{ s, t, p, q }`
- `{ r, g, b, a }`
- `{ 0, 1, 2, 3 }`

比如对于 `vec4 v`，`v.x`/`v.s`/`v.r`/`v[0]` 的意义是一样的。

可以进行矢量计算，比如：

```c#
// 例 1
vec4 a = vec4(1, 2, 3, 4);
vec4 b = a * 2.0; // b 现在是 vec4(2, 4, 6, 8);
// 例 2
attribute vec4 a_position; // 长度 4
uniform vec2 u_resolution; // 长度 2
void main() {
  // 对 a_position 的前两项进行计算
  vec2 zeroToOne = a_position.xy / u_resolution;
  // ...
}
```

有类似于 JS 解构赋值的语法：

```c#
vec4 v;
// 例 1
v.yyyy /* 等价于 */ vec4(v.y, v.y, v.y, v.y)
// 例 2
vec4(v.rgb, 1) /* 等价于 */ vec4(v.r, v.g, v.b, 1)
// 例 3
vec4(1) /* 等价于 */ vec4(1, 1, 1, 1)
```

快捷交换分量位置：
```c#
vec4 color; // 正常顺序为 rgba
gl_FragColor = color.bgra; // 交换了 r 和 b 的位置
```

GLSL 是强类型的：

```c#
float f = 1; // 错误
vec2(1, 1); // vec2() 对类型做了转换，所以不报错
```

#### 2. mat

#### 3. sampler2D

#### 4. bool

#### 5. bvec

### 数据来源

- attribute，属性，从 JS buffer 中获取数据
- uniform，全局变量，在一次 `draw` 的调用期间，值保持不变
- texture，纹理，先简单理解为图片
- varying，可变量，是一种 vertex 给 fragment 传值的方式

||Vertex Shader|Fragment Shader|
|-|-|-|
|attributes|✅||
|uniforms|✅|✅|
|textures|✅|✅|
|varyings||✅|

#### attribute 属性

属性只能用于 vertex shader。

shader 中可能有多个 attribute，比如点的坐标和颜色两个，对应地，JS 中也可以定义多个 buffer，每个 buffer 的赋值都是互不影响的，都有以下几步。

一个完整的 attribute 赋值流程：
```js 
// 1. 准备数据
const bufferData = []; // 待添加的数据
const buffer = gl.createBuffer(); // 创建 buffer
gl.bindBuffer(gl.ARRAY_BUFFER, buffer); // 绑定到 gl.ARRAY_BUFFER 点
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array(bufferData),
  gl.STATIC_DRAW,
); // 添加 buffer 数据
// 2. 获取 attribute 地址
const positionLocation = gl.getAttribLocation(program, 'a_position');
gl.enableVertexAttribArray(positionLocation); // 启用该 attribute
// 3. 设置该 attribute 赋值时的参数
const size = 2; // 每次读取的长度
const type = gl.FLOAT; // 每个单位的数据类型，还有 gl.UNSIGNED_BYTE 等
const normalize = false; // 是否把 [0, 225] 区间的数转到 [0, 1]
const stride = 0; // TODO:
const offset = 0; // 第一次读取数据时的偏移值
gl.vertexAttribPointer(positionLocation, size, type, normalize, stride, offset);
```

attribute 需要提供多个点的数据，比如点的坐标和颜色，而每个点的数据通常都不只有一个值，但是 buffer 是个一维数组，所以还需要提供 size，表示**每次读取的个数**。

也因此，在所有 buffer 都设置完之后，调用 `drawArray()` 时需要传入一个 count 参数说明执行次数。比如每次读取 2 个值，要把长为 length 的数据全部读取完就要执行 length / 2 次。

#### uniform 全局变量

uniform 两种 shader 都可以使用。

默认值为 0。

赋值方式：
1. `gl.getUniformLocation()`
2. `gl.uniform[1234][fi][v]()`

> 赋值函数需要根据变量类型决定，见 [MDN](https://developer.mozilla.org/zh-CN/docs/Web/API/WebGLRenderingContext/uniform)

#### texture 纹理

首先说一下原理。

绘制实际上就是为 `gl_FragColor` 赋值，比如固定值时就是纯色。而纹理中 `gl_FragColor` 的值是**图片上对应的点的颜色**。

类型为 sampler2D。

纹理的设置有三步：
1. 提供图片的缩放数据
2. 提供图片数据
3. 使用前两项数据，在 fragment shader 中调用 `texture2D()`

```js
// 1. 设置图片的缩放数据
const textureLocation = gl.getAttribLocation(program, 'a_texture'); // a_texture 范围 [0, 1]
const buffer = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, buffer);
gl.bufferData(
  gl.ARRAY_BUFFER,
  new Float32Array([
    // 填满整个矩形（范围 [0, 1]
    0.0, 0.0,
    1.0, 0.0,
    0.0, 1.0,
    0.0, 1.0,
    1.0, 0.0,
    1.0, 1.0,
  ]),
  gl.STATIC_DRAW,
);
gl.enableVertexAttribArray(textureLocation);
// 2. 准备图片
const image = await getImage(); // 等待 image 的 onload 事件
// 3. texture 初始化
const texture = gl.createTexture(); // 创建
gl.bindTexture(gl.TEXTURE_2D, texture); // 绑定
// 4. TODO: 以下设置使得可以对任何尺寸的图片进行处理
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
// 4. 添加图片到纹理
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, image);
```

然后在 fragment shader 中

```c#
precision mediump float;
// u_image 变量没有在 JS 中用到
uniform sampler2D u_image;
varying vec2 v_texture;
void main() {
  // 从图片上寻找每个点的颜色
  // 猜测是 JS 中 gl.texImage2D() 使得这里的 texture2D() 可以直接访问到图片数据
  // 不需要显式地把图片数据赋值过来
  // u_image 应该只是一个形参
  gl_FragColor = texture2D(u_image, v_texture).rgba;
}
```

把图片添加为纹理后，就可以对图片进行一些操作了：
- 进行矩阵运算翻转图片的颜色
- 在第二步中可以修改图片的方向

无论图片多大，在纹理中，范围都在 [0, 1]。因此 GLSL 中使用 1 除以图片的宽/高（记为 `u_resolution`），可以获得图片每个像素在纹理中的坐标。在这个基础上，就可以对纹理/图片进行**像素级别的操作**了。

并且，这也引出了卷积矩阵/卷积内核的概念。

**注意，卷积矩阵和后面的 2D 变换矩阵不是同一个东西。**

卷积矩阵，指某个像素及其周围的像素构成的区域，可以是 3x3、5x5 等等大小，卷积内核指对这个卷积矩阵执行的操作。比如根据一定的权重，使用周围像素的颜色修改当前像素的颜色。

> 关于两者的区别，参考 [Convolution Matrix](https://docs.gimp.org/2.6/en/plug-in-convmatrix.html)，原文：   
> Convolution is the treatment of a matrix by another one which is called “kernel”.

#### varying 可变量

其他几种都只能在声明的同时赋值，不能先声明再赋值：

```c#
attribute vec2 a_color; // JS 为 a_color 赋值
uniform vec2 u_color;
varying vec2 v_color;

u_color = a_color; // 错，can't modify a uniform "u_color"
v_color = a_color; // 正确
```

JS -> vertex shader -> fragment shader

#### attribute 和 uniform

以“给矩形添加纯色”为例。

attribute 赋值时，是每次读取 4 个值，设置每个顶点的数据，执行多次，实现覆盖整个图形的效果。无论是绘制轮廓还是添加颜色都是一样的原理。

因此，使用 attribute 添加颜色时，要求执行的次数要跟绘制轮廓的执行次数一致。另外，这也使得允许为不同的三角形添加不同的颜色。

uniform 赋值时，因为是一个固定值，所以每个顶点的颜色数据都是相同的。那么有没有办法使用 uniform 添加不同的颜色？

### 顶点着色器

用于提供顶点的位置。

内置变量：
- `gl_Position`，点的位置，必须赋值，4 元素数组
- `gl_PointSize`，点的大小，默认为 1.0

### 片段着色器

用于提供顶点的颜色。

## 2D 变换

2D 变换就是在图形的原始坐标数据上进行**四则运算**，有四种：
- 平移
- 旋转
- 缩放
- 矩阵

- **不要**在 JS 中直接修改原始数据
- **尽量**提供变换的数据给 GLSL，在 GLSL 中操作原始数据

2D 变换操作的顺序会影响结果。图形旋转不会导致坐标轴方向变化，比如旋转之后拉伸，还是水平和竖直方向上发生拉伸。

### 平移 & 旋转 & 缩放

假设有以下变量：
- `u_translation`，平移数据
- `u_rotation`，旋转数据
- `u_scale`，缩放数据

那么应用了以上三种变换的 fragment shader 会像这样：

```c#
attribute vec2 a_position; // 原始数据
uniform vec2 u_translation;
uniform vec2 u_rotation;
uniform vec2 u_scale;
// 1. 缩放
vec2 scaledPosition = a_position * u_scale;
// 2. 旋转
vec2 rotatedPosition = vec2(
  scaledPosition.x * u_rotation.y + scaledPosition.y * u_rotation.x,
  scaledPosition.y * u_rotation.y - scaledPosition.x * u_rotation.x
);
// 3. 平移
vec2 position = rotatedPosition + u_translation;
```

### 矩阵

**重要提示：如果发现效果与预期不同，极有可能是矩阵的顺序错了。**

矩阵的作用就是把以上三种变换封装到一起。

每种变换都可以写成一个矩阵，把三个矩阵相乘，就得到了最终的矩阵，最后把这个矩阵传递给 fragment shader 进行运算。

好处是什么呢？看一下上面分着的写法，如果现在要添加或者取消一种变换，需要修改 fragment shader 的代码。如果使用矩阵：

- 添加变换时，只需要新定义一个然后多一步乘法
- 取消变换时，只需要把对应矩阵修改为单位矩阵，不需要修改逻辑

并且最终只生成一个矩阵，fragment shader 的代码更简洁。

前面的 canvas 转 clipspace 坐标系的几行代码，实际上就可以写成一个矩阵。示例代码就不贴了，见 [webgl fundamentals](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-2d-matrices.html)

实际上，基本没有什么场景是只有单个变换的，因此矩阵是非常重要的，到后面三维变换的部分也是一样。

这里可以封装一些函数，返回常用矩阵，比如：
- 单位矩阵
- 平移矩阵
- 旋转矩阵
- 缩放矩阵
- canvas 转 clipspace

#### 矩阵的顺序/乘法交换律

**再说一遍：如果发现效果与预期不同，极有可能是矩阵的顺序错了。**

**更重要的提示：多个矩阵组合时，按照从后向前的顺序看比较好理解。**
> 详情见 [webgl fundamental](https://webglfundamentals.org/webgl/lessons/zh_cn/webgl-2d-matrices.html)

矩阵在一定条件下才满足乘法交换律，见[百度知道](https://zhidao.baidu.com/question/110424802)。

多个操作单独执行和封装为矩阵并没有什么两样，还是需要有先后顺序的。举两个栗子：

1. 坐标系转换

   canvas 转 clipspace 时：

   - 如果在 fragment shader 中分步计算，需要先执行其他二维变换操作，最后再进行坐标系转换
   - 如果把坐标系转换写为矩阵在 JS 中运算，需要先进行坐标转换，再执行其他二维变换

2. 以图形中心为原点旋转

   一般情况下，旋转变换的旋转中心是 canvas 原点，即左上角。可以通过额外添加一个平移变换修改原点的位置，实现以图形的中心为旋转原点。

   这里有一个很重要的顺序问题。假设现在对该图形添加了平移 A、旋转、缩放所有三种操作，再算上修改原点位置的平移 B，一共是 4 个矩阵，那么顺序必须为：平移A、旋转、平移B，缩放的位置没有限制。

总结一下上面两个例子，同时具备

1. 三种平移操作
2. canvas 转 clipspace
3. 以图形中心为原点旋转

三个功能的的矩阵操作可能是像这样的：

```js
// 1. 先转换坐标系
let matrix = projection(gl.canvas.width, gl.canvas.height);
// 2. 再执行二维操作
matrix = translate(matrix, translateX, translateY); // 顺序必须是先 translation 后 rotation
matrix = rotate(matrix, angle);
matrix = scale(matrix, zoomX, zoomY);
// 3. 最后修改原点
matrix = translate(matrix, -50, -75);
```

### framebuffer 帧缓冲

当需要连续添加多个纹理时，需要保存每一次处理后的纹理，在这个纹理上继续进行下一次处理，即：原始纹理 -> 纹理 1 -> 纹理 2 -> ... -> 最终纹理 n。这时需要帧缓冲。

一般的纹理渲染是绘制到了屏幕上，而帧缓冲渲染是把纹理绘制到了 framebuffer 中，没有任何显示，等到所有纹理处理完成后再把最终结果显示到屏幕上。

只需要准备两对 texture/framebuffer，每次处理都把另一对的旧值覆盖掉即可。

关键步骤
```js
const framebufferObject = gl.createFramebuffer();
// 渲染到 framebuffer
gl.bindFramebuffer(gl.FRAMEBUFFER, framebufferObject);
// 退出 framebuffer，渲染到屏幕
gl.bindFramebuffer(gl.FRAMEBUFFER, null);
```

## 3D 变换

对于一个三角形，如果它在一个二维平面上，是只有一个面的，即朝向我们的这一面。但是到了三维空间，它就得分前面和后面了。

三角形是由三个顶点绘制的，webgl 规定，当这三个顶点的绘制顺序：

- 为顺时针时，看到的面为反面
- 为逆时针时，看到的面为正面

### 几个 API

- `gl.enable(gl.CULL_FACE)`
   如上面所说，一个平面图形是有正反两个面的。如果只需要其中一面，可以开启这个属性，只绘制正面，不绘制反面
- `gl.enable(gl.DEPTH_TEST)`
   没有开启这个属性的时候，空间里的每一个点都没有记录其“深度”，即该点到观察者的距离，导致虽然有些部分本应该被遮挡，但是实际上仍然渲染出来了。